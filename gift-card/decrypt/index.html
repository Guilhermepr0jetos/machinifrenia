<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Abrir Cart√£o</title>
<style>
body {
  font-family: Arial, sans-serif;
  margin: 2em;
  background: #f4f4f4;
  color: #333;
}
h1 {
  text-align: center;
}
label {
  display: block;
  margin-top: 1em;
  font-weight: bold;
}
input[type="file"], input[type="text"] {
  display: block;
  margin-top: 0.5em;
  padding: 0.4em;
  width: 100%;
  box-sizing: border-box;
}
button {
  margin-top: 1.2em;
  padding: 0.6em 1.2em;
  font-size: 1em;
  background: #0078d4;
  color: white;
  border: none;
  cursor: pointer;
}
button:hover {
  background: #005a9e;
}
#log {
  margin-top: 1em;
  padding: 0.5em;
  background: #fff;
  border: 1px solid #ccc;
  height: 150px;
  overflow-y: auto;
  font-family: monospace;
}
#log .ok { color: green; }
#log .err { color: red; }
#log .warn { color: orange; }
#message {
  margin-top: 1em;
  padding: 0.8em;
  background: #e0f7e0;
  border: 1px solid #b2d8b2;
  font-weight: bold;
  white-space: pre-wrap;
}
</style>
</head>
<body>

<h1>üîê Abrir Cart√£o</h1>

<label>Arquivo de refer√™ncia:
  <input type="file" id="refFile" accept=".ref,.txt,.bin">
</label>

<label>Chave descart√°vel:
  <input type="text" id="dKey" placeholder="Cole aqui a chave">
</label>

<label>Arquivo .bin do cart√£o:
  <input type="file" id="binFile" accept=".bin">
</label>

<button id="btnOpen">Abrir</button>

<div id="log"></div>

<div id="message">‚Äî</div>

<script>
const te = new TextEncoder();
const td = new TextDecoder();
const logEl = document.getElementById('log');

function log(line, cls) {
  const prefix = cls === 'err' ? '‚úñ ' : cls === 'ok' ? '‚úî ' :
                 cls === 'warn' ? '‚ö† ' : '‚Ä¢ ';
  const node = document.createElement('div');
  if (cls) node.className = cls;
  node.textContent = prefix + line;
  logEl.appendChild(node);
  logEl.scrollTop = logEl.scrollHeight;
}
function clearLog(){ logEl.textContent = ''; }

function bytesFromB64url(s) {
  const b64 = s.replace(/-/g, '+').replace(/_/g, '/');
  const pad = b64.length % 4 === 2 ? '==' :
              b64.length % 4 === 3 ? '=' : '';
  const bin = atob(b64 + pad);
  return Uint8Array.from(bin, c => c.charCodeAt(0));
}

async function sha256Hex(data) {
  const buf = await crypto.subtle.digest('SHA-256', data);
  return [...new Uint8Array(buf)]
         .map(b => b.toString(16).padStart(2,'0'))
         .join('');
}

async function getUtcNowIso() {
  const r = await fetch('https://worldtimeapi.org/api/timezone/Etc/UTC', { cache: 'no-store' });
  if (!r.ok) throw new Error('Falha ao consultar hora UTC');
  const j = await r.json();
  return new Date(j.utc_datetime).toISOString();
}

async function readText(file) {
  return new Promise((res, rej) => {
    const fr = new FileReader();
    fr.onload = () => res(fr.result);
    fr.onerror = rej;
    fr.readAsText(file);
  });
}

// üîπ Verifica√ß√£o de chave no keys.json
async function fetchKeys() {
  const r = await fetch('./keys.json', { cache: 'no-store' });
  if (!r.ok) throw new Error('N√£o foi poss√≠vel carregar keys.json');
  return await r.json();
}
function isKeyAllowed(db, key) {
  const k = String(key || '').trim();
  const valids = new Set(db.validas || []);
  const invalids = new Set(db.invalidas || []);
  if (k.length === 0) return false;
  if (invalids.has(k)) return false;
  if (valids.size > 0) return valids.has(k);
  return !invalids.has(k);
}

document.getElementById('btnOpen').addEventListener('click', async () => {
  clearLog();
  document.getElementById('message').textContent = '‚Äî';
  try {
    const refFile = document.getElementById('refFile').files[0];
    const dKey = document.getElementById('dKey').value.trim();
    const binFile = document.getElementById('binFile').files[0];

    if (!refFile) throw new Error('Selecione o arquivo de refer√™ncia.');
    if (!dKey) throw new Error('Informe a chave descart√°vel.');
    if (!binFile) throw new Error('Selecione o arquivo .bin.');

    // 1Ô∏è‚É£ Verifica chave no keys.json
    log('Verificando chave no keys.json‚Ä¶');
    const keysDb = await fetchKeys();
    if (!isKeyAllowed(keysDb, dKey)) {
      throw new Error('Chave descart√°vel inv√°lida ou revogada.');
    }
    log('Chave aceita pelo keys.json.', 'ok');

    // 2Ô∏è‚É£ Ler e validar artefato
    log('Lendo artefato‚Ä¶');
    const text = await readText(binFile);
    const art = JSON.parse(text);

    // 3Ô∏è‚É£ Verificar expira√ß√£o via hora UTC
    log('Consultando hora UTC‚Ä¶');
    const nowIso = await getUtcNowIso();
    const nowT = new Date(nowIso).getTime();
    const expT = new Date(art.exp).getTime();
    if (!isFinite(expT)) throw new Error('Campo exp inv√°lido.');
    if (nowT > expT) {
      throw new Error('Cart√£o expirado (UTC).');
    }
    log('Validade ok at√© ' + new Date(expT).toISOString(), 'ok');

    // 4Ô∏è‚É£ Derivar chave a partir do arquivo de refer√™ncia
    const refBytes = new Uint8Array(await refFile.arrayBuffer());
    if (art.refHash) {
      const gotHash = await sha256Hex(refBytes);
      if (gotHash !== art.refHash) {
        throw new Error('Arquivo de refer√™ncia n√£o corresponde ao usado na cria√ß√£o.');
      }
    }
    const salt = bytesFromB64url(art.salt);
    const baseKey = await crypto.subtle.importKey('raw', refBytes, 'HKDF', false, ['deriveKey']);
    const aesKey = await crypto.subtle.deriveKey(
      { name: 'HKDF', hash: 'SHA-256', salt, info: te.encode('cartao-v1') },
      baseKey,
      { name: 'AES-GCM', length: 256 },
      false,
      ['decrypt']
    );

    // 5Ô∏è‚É£ Descriptografia AES‚ÄëGCM
    const iv = bytesFromB64url(art.iv);
    const ct = bytesFromB64url(art.ct);
    const aad = te.encode(dKey + '|' + art.exp);

    log('Descriptografando‚Ä¶');
    const ptBuf = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv, additionalData: aad },
      aesKey,
      ct
    );

    const message = td.decode(ptBuf);
    log('Descriptografia conclu√≠da.', 'ok');
    document.getElementById('message').textContent = message;

  } catch (err) {
    log(String(err.message || err), 'err');
  }
});
</script>

</body>
</html>
