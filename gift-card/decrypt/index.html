<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8"><title>Ativar Gift Card</title>
<style>body{font-family:sans-serif;padding:2rem;max-width:760px;margin:auto} label{display:block;margin-top:1rem}</style>
</head>
<body>
<h2>ðŸ”“ Ativar Gift Card</h2>

<label>Arquivo do gift card (.bin)</label>
<input id="bin" type="file" />

<label>Arquivo de referÃªncia (o mesmo usado na criaÃ§Ã£o)</label>
<input id="ref" type="file" />

<button id="dec">Descriptografar</button>

<div id="info" style="margin-top:1rem"></div>
<div id="server" style="margin-top:1rem"></div>

<script>
/*
Layout do .bin:
[0..3]   = "GFC1" (ASCII)
[4..11]  = expiresAtMs (Uint64 big-endian)
[12..23] = IV (12 bytes)
[24..]   = ciphertext+tag (AES-GCM)
O cabeÃ§alho [0..11] Ã© usado como AAD no AES-GCM.
*/

const API_BASE = ""; // defina sua API do jogo (Vercel, etc.)
const enc = new TextEncoder(), dec = new TextDecoder();

function toHex(u8) {
  return [...u8].map(b => b.toString(16).padStart(2,'0')).join('');
}

async function sha256Hex(str){
  const h = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(str));
  return [...new Uint8Array(h)].map(b=>b.toString(16).padStart(2,"0")).join("");
}

function readUint64BE(view, offset = 0) {
  if (typeof view.getBigUint64 === 'function') {
    return Number(view.getBigUint64(offset, false));
  }
  const hi = view.getUint32(offset, false);
  const lo = view.getUint32(offset + 4, false);
  return hi * 2**32 + lo;
}

document.getElementById("dec").onclick = async () => {
  const binFile = document.getElementById("bin").files[0];
  const refFile = document.getElementById("ref").files[0];
  const info = document.getElementById("info");
  const server = document.getElementById("server");
  info.textContent = ""; server.textContent = "";

  if (!binFile || !refFile) { info.textContent = "Envie o .bin e o arquivo de referÃªncia."; return; }

  // LÃª .bin
  const buf = await binFile.arrayBuffer();
  const u8 = new Uint8Array(buf);

  // Valida magic
  const magic = new TextDecoder().decode(u8.slice(0,4));
  if (magic !== "GFC1") {
    info.textContent = "Formato invÃ¡lido do .bin (magic ausente).";
    return;
  }

  // LÃª validade (uint64 big-endian, ms desde epoch)
  const dv = new DataView(buf, 4, 8);
  const expiresMs = readUint64BE(dv, 0);
  const expiresAt = new Date(expiresMs);

  // Checagem de validade ANTES de tentar descriptografar
  const now = Date.now();
  if (!Number.isFinite(expiresMs) || expiresMs <= 0) {
    info.textContent = "CabeÃ§alho sem validade vÃ¡lida.";
    return;
  }
  if (now > expiresMs) {
    info.innerHTML = `<strong>Status:</strong> expirado em ${expiresAt.toLocaleString()} â€” operaÃ§Ã£o abortada.`;
    return;
  }

  // LÃª IV e ciphertext
  const iv = u8.slice(12, 24);
  const ciphertext = buf.slice(24);

  // Deriva chave do arquivo de referÃªncia
  const refBuf = await refFile.arrayBuffer();
  const keyMat = await crypto.subtle.digest("SHA-256", refBuf);
  const key = await crypto.subtle.importKey("raw", keyMat, {name:"AES-GCM"}, false, ["decrypt"]);

  // Descriptografa com AAD = cabeÃ§alho (magic + expiresAt)
  try {
    const aad = u8.slice(0, 12); // bytes [0..11]
    const plain = await crypto.subtle.decrypt({name:"AES-GCM", iv, additionalData: aad}, key, ciphertext);
    const data = JSON.parse(new TextDecoder().decode(plain));

    // Mostra metadados
    let html = `<strong>giftId:</strong> ${data.giftId}<br>
                <strong>valor:</strong> ${data.meta?.value ?? "â€”"} ${data.meta?.currency ?? ""}<br>
                <strong>validade (header):</strong> ${expiresAt.toLocaleString()}<br>
                <strong>validade (payload):</strong> ${data.meta?.expiresAt || "â€”"}<br>`;
    if (data.attachment?.base64) {
      const a = document.createElement("a");
      a.href = data.attachment.base64; a.download = data.attachment.name || "anexo";
      a.textContent = "Baixar anexo";
      const wrap = document.createElement("div"); wrap.appendChild(a);
      info.innerHTML = html; info.appendChild(wrap);
    } else {
      info.innerHTML = html;
    }

    // Checagem no servidor do jogo (opcional, mas recomendado)
    if (API_BASE) {
      const codeHash = await sha256Hex(data.code);
      // 1) Verificar se pode ativar (o backend tambÃ©m deve validar a validade do cabeÃ§alho)
      const checkRes = await fetch(`${API_BASE}/api/redeem/check?giftId=${encodeURIComponent(data.giftId)}&codeHash=${codeHash}`, { headers: { "X-Expires-At": String(expiresMs) }});
      const check = await checkRes.json();
      server.innerHTML = `<pre>Check: ${JSON.stringify(check, null, 2)}</pre>`;

      // 2) Se permitido, botÃ£o para ativar
      if (check.activable) {
        const btn = document.createElement("button");
        btn.textContent = "Ativar agora";
        btn.onclick = async () => {
          const actRes = await fetch(`${API_BASE}/api/redeem/activate`, {
            method:"POST",
            headers:{"Content-Type":"application/json"},
            body: JSON.stringify({ giftId: data.giftId, codeHash, expiresAt: expiresMs })
          });
          const act = await actRes.json();
          server.innerHTML = `<pre>Ativado: ${JSON.stringify(act, null, 2)}</pre>`;
        };
        server.appendChild(btn);
      }
    }
  } catch(e) {
    // Se alguÃ©m adulterar a validade no cabeÃ§alho, a autenticaÃ§Ã£o GCM falha aqui
    info.textContent = "Falha ao descriptografar ou cabeÃ§alho adulterado. Confirme o arquivo de referÃªncia e a integridade do .bin.";
  }
};
</script>
</body>
</html>
